# Bonnes pratiques pour le d√©veloppement de l'application LSF

üìå **Note importante :** Avant d'impl√©menter de nouvelles fonctionnalit√©s ou de modifier l'existant, **v√©rifiez toujours la coh√©rence avec :**
- üîπ **L'arborescence de l'IA** (`arborescence_AI`) pour assurer une structure harmonieuse.
- üîπ **Les diagrammes d'√©tat** pour garantir que les transitions et comportements sont bien d√©finis.

## 1. Organisation des imports

Respectez ces principes pour √©viter les probl√®mes d'import cycliques:

```typescript
// ‚úÖ BON: Utiliser les alias d√©finis dans tsconfig.json
import { SpatialVector } from '@spatial/types';
import { ProsodicPattern } from '@ai-types/lsf';
import { SystemOrchestrator } from '@ai/coordinators/SystemOrchestrator';

// ‚ùå MAUVAIS: Chemins relatifs complexes
import { SpatialVector } from '../../../../spatial/types';
import { ProsodicPattern } from '../../../types/lsf';
```

- Cr√©ez et maintenez des fichiers **barrel (index.ts)** dans chaque dossier pour faciliter les imports.
- Envisagez d'utiliser des **path aliases** dans `tsconfig.json` pour simplifier les imports:
  ```json
  {
    "compilerOptions": {
      "paths": {
        "@types/*": ["src/types/*"],
        "@components/*": ["src/components/*"]
      }
    }
  }
  ```

## 2. Typage strict

Respectez toujours les r√®gles de typage strict:

```typescript
// ‚úÖ BON: Types explicites
function processData<T>(data: T[], callback: (item: T, index: number) => void): void {
  data.forEach((item, index) => callback(item, index));
}

// ‚ùå MAUVAIS: Types implicites ou any
function processData(data, callback) {
  data.forEach((item, index) => callback(item, index));
}
```

- Activez les options TypeScript strictes: **strictNullChecks**, **noImplicitAny**, etc.
- √âvitez les assertions de type sauf si absolument n√©cessaire.
- Utilisez des **types d√©di√©s** pour √©viter les `unknown` inutiles.
- **V√©rifiez si un √©l√©ment est r√©ellement utilis√© avant de l'impl√©menter** pour √©viter du code inutile et une complexit√© accrue.

## 3. Structure des classes

Suivez une structure coh√©rente pour les classes:

```typescript
export class ExampleClass {
  private static instance: ExampleClass; // Propri√©t√© priv√©e statique
  private data: Map<string, unknown>; // Propri√©t√© priv√©e
  
  private constructor() {
    this.data = new Map();
  }
  
  public static getInstance(): ExampleClass {
    if (!ExampleClass.instance) {
      ExampleClass.instance = new ExampleClass();
    }
    return ExampleClass.instance;
  }
  
  public getData(key: string): unknown {
    return this.data.get(key);
  }
  
  private validateKey(key: string): boolean {
    return key.length > 0;
  }
}
```

- **Principe de responsabilit√© unique**: chaque classe/module ne devrait avoir qu'une seule raison de changer.
- **Divisez les fichiers trop grands** en modules plus petits et sp√©cialis√©s.
- **Avant d'ajouter une nouvelle impl√©mentation, v√©rifiez sa pertinence et son impact sur l'architecture en vous r√©f√©rant au fichier `arborescence_AI` et aux diagrammes d'√©tat.**

## 4. Gestion des erreurs

Utilisez des types d'erreur sp√©cifiques:

```typescript
export class ValidationError extends Error {
  public readonly validationErrors: string[];
  
  constructor(message: string, errors: string[] = []) {
    super(message);
    this.name = 'ValidationError';
    this.validationErrors = errors;
  }
}

try {
  // Op√©ration risqu√©e
} catch (error) {
  if (error instanceof ValidationError) {
    logger.warn('Validation failed', { errors: error.validationErrors });
  } else {
    logger.error('Unknown error', { error });
  }
}
```

- Cr√©ez des **classes d'erreur personnalis√©es**.
- G√©rez les erreurs au niveau appropri√©.
- Journalisez les erreurs de mani√®re coh√©rente.

## 5. Outils d'analyse statique

Pour identifier et √©viter les √©l√©ments inutilis√©s :

- **ESLint avec `eslint-plugin-unused-imports`** : D√©tecte les imports inutilis√©s.
- **`ts-prune`** : Identifie les fonctions et variables non utilis√©es.

Int√©grer ces outils dans le processus de d√©veloppement permet d‚Äôassurer un code plus propre et optimis√©.

## 6. Tests unitaires

- Utilisez des **mocks** pour isoler les composants pendant les tests.
- Testez les **cas limites et conditions d'erreur**.
- Int√©gration continue : ex√©cuter les tests automatiquement.

## 7. Documentation

Utilisez des commentaires JSDoc:

```typescript
/**
 * G√®re les mod√®les prosodiques en LSF.
 *
 * @example
 * const patterns = new LSFProsodicPatterns();
 * const modifiedVector = patterns.applyProsodicModifier(vector, 'emphatic');
 */
export class LSFProsodicPatterns {
  // ...
}
```

- Cr√©ez un **README.md** pour chaque module majeur.
- Documentez toutes les **interfaces publiques**.

## 8. Conventions de nommage

- **Interfaces**: `IValidator`, `ProsodicPattern`
- **Types**: `ColorType`, `SpatialVector`
- **Classes**: `ExpressionValidator`
- **Constantes**: `MAX_CACHE_SIZE`
- **Fichiers**:
  - Classes: `LSFProsodicPatterns.ts`
  - Interfaces: `validator-interfaces.ts`
  - Types: `spatial-types.ts`

## 9. S√©curit√© et validation

```typescript
function validateSpatialVector(vector: unknown): SpatialVector {
  if (typeof vector !== 'object' || vector === null) {
    throw new ValidationError('Invalid spatial vector');
  }

  const { x, y, z } = vector as Record<string, unknown>;
  if (typeof x !== 'number' || typeof y !== 'number' || typeof z !== 'number') {
    throw new ValidationError('Invalid spatial vector: x, y, and z must be numbers');
  }
  return { x, y, z };
}
```

## 10. Performance et Memory Leaks

```typescript
class ComponentManager {
  private listeners: Map<string, () => void> = new Map();
  
  public addListener(id: string, callback: () => void): void {
    this.listeners.set(id, callback);
  }
  
  public removeListener(id: string): void {
    this.listeners.delete(id);
  }
  
  public destroy(): void {
    this.listeners.clear();
  }
}
```